# ******************************************************************
# Need: omz, p10k
# And this command: [[ -f ~/.zshrc.local ]] && source ~/.zshrc.local
# ******************************************************************


# ***
# Zsh
# ***

plugins=(git ssh-agent)

# lead zsh to load custom completions
FPATH="$HOME/.zsh/completions:$FPATH"
autoload -Uz compinit && compinit

# p10k custom
typeset -g POWERLEVEL9K_VI_INSERT_MODE_CURSOR=block
typeset -g POWERLEVEL9K_VI_COMMAND_MODE_CURSOR=block


# *****
# Proxy
# *****

# clash meta proxy -> since disabled system proxy I'll prune them some days :O
# export https_proxy=http://127.0.0.1:7897
# export http_proxy=http://127.0.0.1:7897
# export all_proxy=socks5://127.0.0.1:7897
# export HTTPS_PROXY=$https_proxy
# export HTTP_PROXY=$http_proxy
# export ALL_PROXY=$all_proxy

# unset all
alias noproxy='unset https_proxy http_proxy all_proxy HTTPS_PROXY HTTP_PROXY ALL_PROXY'


# ***
# Env
# ***

export EDITOR=nvim

# zoxide
eval "$(zoxide init zsh)"


# *****
# Alias
# *****

# sor vim, happy with nvim now :D
alias vi=nvim
alias vim=nvim

alias ra=ranger

# normalize git
alias git='LANG=en_US.UTF-8 git'

# zed editor
alias zed="open -a /Applications/Zed.app -n"

# alias chrome='open -na Google\ Chrome --args --user-data-dir="'"$HOME"'/Library/Application Support/Google/Chrome/user0/" --disable-web-security --disable-site-isolation-trials'

# yazi
function y() {
  local tmp="$(mktemp -t "yazi-cwd.XXXXXX")"
  yazi "$@" --cwd-file="$tmp"
  if cwd="$(cat -- "$tmp")" && [ -n "$cwd" ] && [ "$cwd" != "$PWD" ]; then
    builtin cd -- "$cwd"
  fi
  rm -f -- "$tmp"
}


# **********
# JavaScript
# **********

# better yarn, in office :(
# alias yarn="yarn --network-timeout 9999999"

# npm home
export NPM_HOME="$HOME/.local/share/fnm/aliases/default/lib"
export PATH="$NPM_HOME:$PATH"

# pnpm home
export PNPM_HOME="$HOME/Library/pnpm"
case ":$PATH:" in
  *":$PNPM_HOME:"*) ;;
  *) export PATH="$PNPM_HOME:$PATH" ;;
esac
export PATH="$HOME/.pnpm-global/bin:$PATH"

# pnpm completion
if type compdef &>/dev/null; then
  _pnpm_completion () {
    local reply
    local si=$IFS

    IFS=$'\n' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" SHELL=zsh pnpm completion-server -- "${words[@]}"))
    IFS=$si

    if [ "$reply" = "__tabtab_complete_files__" ]; then
      _files
    else
      _describe 'values' reply
    fi
  }
# When called by the Zsh completion system, this will end with
# "loadautofunc" when initially autoloaded and "shfunc" later on, otherwise,
# the script was "eval"-ed so use "compdef" to register it with the
# completion system
if [[ $zsh_eval_context == *func ]]; then
  _pnpm_completion "$@"
else
  compdef _pnpm_completion pnpm
fi
fi

# fnm
eval "$(fnm env --use-on-cd --shell zsh)"

# bun
export PATH="$HOME/.bun/bin:$PATH"
# alias bun='env -u http_proxy -u https_proxy -u HTTP_PROXY -u HTTPS_PROXY bun'


# ******
# Python
# ******

# pyenv home
export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"


# ****
# Ruby
# ****

# Added by `rbenv init` on Tue May 20 14:14:32 CST 2025
eval "$(rbenv init - --no-rehash zsh)"


# ********
# C family
# ********

# llvm
export PATH="/opt/homebrew/opt/llvm/bin:$PATH"
export LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"


# **********
# Mobile dev
# **********

# flutter
export PATH="$HOME/development/flutter/bin:$PATH"


# **********
# editor/IDE
# **********

# JetBrains's stuff
export PATH="/Applications/WebStorm.app/Contents/MacOS:$PATH"


# *****
# macOS
# *****

# homebrew
export PATH="/opt/homebrew/bin:/opt/homebrew/sbin:$PATH"

if type brew &>/dev/null
then
  FPATH="$(brew --prefix)/share/zsh/site-functions:${FPATH}"
  FPATH="$HOME/.rbenv/completions:$FPATH"

  autoload -Uz compinit
  compinit
fi

alias buu='brew update && brew upgrade'

# export HOMEBREW_NO_INSTALL_FROM_API=1


# **************
# AI tools sutff
# **************

# claude-code
export PATH="$HOME/.local/bin:$PATH"
[[ -f "$HOME/.claude-keys" ]] && source "$HOME/.claude-keys"
[[ -f "$HOME/.gemini-keys" ]] && source "$HOME/.gemini-keys"


# ******
# ffmpeg
# ******

# compress
ffcompress() {
  if [[ -z "$1" ]]; then
    echo "Usage: ffcompress <file> [CRF value (default as 23)]"
    return 1
  fi

  local input="$1"
  local crf="${2:-23}"

  if [[ ! -f "$input" ]]; then
    echo "File not found"
    return 1
  fi

  local filename="${input%.*}"
  local ext="${input##*.}"

  echo "Compress params: CRF=${crf}"
  ffmpeg -i "$input" -vcodec libx264 -crf "$crf" "${filename}_compressed.${ext}"
}

# compress files in current dir
ffcompressg() {
  local crf="${1:-23}"

  echo "Batch compress with CRF=${crf}"

  if [ ! -d "compressed" ]; then
    mkdir compressed
  fi

  for file in *.*; do
    # only files
    if [ -d "$file" ]; then
      continue
    fi

    filename=$(basename "$file")
    extension="${filename##*.}"
    name="${filename%.*}"

    output="compressed/${name}_compressed.${extension}"

    echo "Compressing: ${file} → ${output}"
    ffmpeg -i "$file" -vcodec libx264 -crf "$crf" "$output"
  done

  echo "-------------------------------------------------------------------"
  echo "| Compression completed. All files are saved in 'compressed/'.    |"
  echo "-------------------------------------------------------------------"
}

# convert specific file to specific format
ffconvert() {
  if [[ -z "$1" ]] || [[ -z "$2" ]]; then
    echo "Usage: ffconvert <file> <format>"
    echo "Example: ffconvert video.mp4 mkv"
    return 1
  fi

  local input="$1"
  local target_ext="$2"

  if [[ ! -f "$input" ]]; then
    echo "File not found"
    return 1
  fi

  local filename="${input%.*}"

  echo "Converting: ${input} → ${filename}.${target_ext}"
  ffmpeg -i "$input" -c copy "${filename}.${target_ext}"
}

# convert files in current dir to specific format
ffconvertg() {
  if [ "$#" -ne 1 ]; then
    echo "Usage: ffc <format>"
    return 1
  fi

  format=$1

  if [ ! -d "converted" ]; then
    mkdir converted
  fi

  for file in *.*; do
    # only files
    if [ -d "$file" ]; then
      continue
    fi

    filename=$(basename "$file")
    extension="${filename##*.}"
    name="${filename%.*}"

    output="converted/${name}.${format}"

    ffmpeg -i "$file" "$output"
  done

  echo "--------------------------------------------------------------"
  echo "| Conversion completed. All files are saved in 'converted/'. |"
  echo "--------------------------------------------------------------"
}

